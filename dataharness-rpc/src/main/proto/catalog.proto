syntax = "proto3";

package io.github.jordepic.proto;

option java_multiple_files = true;
option java_package = "io.github.jordepic.proto";
option java_outer_classname = "CatalogProto";

enum SchemaType {
  SCHEMA_TYPE_UNSPECIFIED = 0;
  AVRO = 1;
  PROTOBUF = 2;
}

service CatalogService {
  /**
   * Creates a table with the given name.
   */
  rpc CreateTable(CreateTableRequest) returns (CreateTableResponse) {}
  /**
   * Updates table sources according to input. Table sources not listed here will not be modified.
   * Sources are updated atomically via a database transaction.
   * Will throw an exception if the passed in modifier does not align with existing claims on any sources.
   * If successful, any claims on modified sources will be removed.
   */
  rpc UpsertSources(UpsertSourcesRequest) returns (UpsertSourcesResponse) {}
  /**
   * Fetches table sources table metadata and sources. Table sources are loaded atomically via a database transaction.
   */
  rpc LoadTable(LoadTableRequest) returns (LoadTableResponse) {}
  /**
   * List available tables.
   */
  rpc ListTables(ListTablesRequest) returns (ListTablesResponse) {}
  /**
   * Set schema to use when reading each table source.
   */
  rpc SetSchema(SetSchemaRequest) returns (SetSchemaResponse) {}
  /**
   * Drop a table.
   */
  rpc DropTable(DropTableRequest) returns (DropTableResponse) {}
  /**
   * Check if a table exists.
   */
  rpc TableExists(TableExistsRequest) returns (TableExistsResponse) {}
  /**
   * Allows grabbing a lock on a set of table data sources such that any other process trying to modify them will fail.
   * This lock does NOT expire.
   */
  rpc ClaimSources(ClaimSourcesRequest) returns (ClaimSourcesResponse) {}
}

message CreateTableRequest {
  string name = 1;
}

message CreateTableResponse {
  bool success = 1;
  string message = 2;
  int64 table_id = 3;
}

message UpsertSourcesRequest {
  repeated SourceUpdate sources = 1;
}

message SourceUpdate {
  string table_name = 1;
  oneof source {
    KafkaSourceMessage kafka_source = 2;
    IcebergSourceMessage iceberg_source = 3;
    YugabyteDBSourceMessage yugabytedb_source = 4;
    PostgresDBSourceMessage postgresdb_source = 5;
  }
}

message UpsertSourcesResponse {
  bool success = 1;
  string message = 2;
}

message LoadTableRequest {
  string table_name = 1;
}

message LoadTableResponse {
  optional string avro_schema = 1;
  optional string iceberg_schema = 2;
  optional string protobuf_schema = 3;
  repeated TableSourceMessage sources = 4;
}

message KafkaSourceMessage {
  string name = 1;
  string trino_catalog_name = 2;
  string trino_schema_name = 3;
  int64 start_offset = 4;
  int64 end_offset = 5;
  int32 partition_number = 6;
  string topic_name = 7;
  string broker_urls = 8;
  SchemaType schema_type = 9;
  string schema = 10;
  string modifier = 11;
  string partition_filter = 12;
}

message IcebergSourceMessage {
  string name = 1;
  string trino_catalog_name = 2;
  string trino_schema_name = 3;
  string table_name = 4;
  int64 read_timestamp = 5;
  string spark_catalog_name = 6;
  string spark_schema_name = 7;
  string modifier = 8;
  string partition_filter = 9;
}

message YugabyteDBSourceMessage {
  string name = 1;
  string trino_catalog_name = 2;
  string trino_schema_name = 3;
  string table_name = 4;
  string jdbc_url = 5;
  string username = 6;
  string password = 7;
  int64 read_timestamp = 8;
  string modifier = 9;
  string partition_filter = 10;
}

message PostgresDBSourceMessage {
  string name = 1;
  string trino_catalog_name = 2;
  string trino_schema_name = 3;
  string table_name = 4;
  string jdbc_url = 5;
  string username = 6;
  string password = 7;
  int64 read_timestamp = 8;
  string history_table_name = 9;
  string table_name_no_tstzrange = 10;
  string history_table_name_no_tstzrange = 11;
  string modifier = 12;
  string partition_filter = 13;
}

message TableSourceMessage {
  string table_name = 1;
  oneof source {
    KafkaSourceMessage kafka_source = 2;
    IcebergSourceMessage iceberg_source = 3;
    YugabyteDBSourceMessage yugabytedb_source = 4;
    PostgresDBSourceMessage postgresdb_source = 5;
  }
}

message SetSchemaRequest {
  string table_name = 1;
  optional string avro_schema = 2;
  optional string iceberg_schema = 3;
  optional string protobuf_schema = 4;
}

message SetSchemaResponse {
  bool success = 1;
  string message = 2;
}

message ListTablesRequest {
}

message ListTablesResponse {
  repeated string table_names = 1;
}

message DropTableRequest {
  string table_name = 1;
}

message DropTableResponse {
  bool success = 1;
  string message = 2;
}

message TableExistsRequest {
  string table_name = 1;
}

message TableExistsResponse {
  bool exists = 1;
}

message SourceToClaim {
  string name = 1;
  string modifier = 2;
}

message ClaimSourcesRequest {
  repeated SourceToClaim sources = 1;
}

message ClaimSourcesResponse {
  bool success = 1;
  string message = 2;
}
